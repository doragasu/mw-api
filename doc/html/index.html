<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MegaWiFi: MegaWiFi API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MegaWiFi
   &#160;<span id="projectnumber">0.8</span>
   </div>
   <div id="projectbrief">MegaWiFi API documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MegaWiFi API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Introduction</h1>
<p>This repository contains the MegaWiFi API, to use the WiFi capabilities of the MegaWiFi cartridges.</p>
<h1>API documentation</h1>
<p>The full API documentation <a href="https://doragasu.github.io/mw-api/doc/html/index.html">can be found here</a>.</p>
<h1>Building</h1>
<p>You will need a complete Genesis/Megadrive toolchain. The sources use some C standard library calls, such as <code>memcpy()</code>, <code>setjmp()</code>, <code>longjmp()</code>, etc. Thus your toolchain must include a C standard library implementation such as <em>newlib</em>.</p>
<p>To build the files, you can use the provided Makefile, suiting it to your needs, or just add the source files to your project to build them.</p>
<h1>Overview</h1>
<p>The MegaWiFi API consists of the following modules:</p><ul>
<li>loop: Loop handling for single threaded Megadrive programs.</li>
<li>mpool: Simple memory pool implementation.</li>
<li>megawifi: Communications with the WiFi module and the Internet.</li>
<li>mw-msg: MegaWiFi command message definitions.</li>
<li>util: General purpose utility functions and macros.</li>
</ul>
<p>The <code>mw-msg</code> module contains the message definitions for the different MegaWiFi commands and command replies. Fear not because usually you do not need to use this module, unless you are doing something pretty advanced not covered by the <code>megawifi</code> module API.</p>
<p>The <code>util</code> module contains general purpose functions and macros not fitting in the other modules, such as <code><a class="el" href="group__util.html#ga851ec0ef4a4c9ca0cf855fe0925946b5" title="This function evaluates the data entered on the input Menu structure, to guess if it corresponds to a...">ip_validate()</a></code> to check if a string is a valid IP address, <code><a class="el" href="group__util.html#ga1592ef63a7bfa19eed825eb2a90e80d0" title="Converts a character string representing an 8-bit unsigned number, to its binary (uint8_t) representa...">str_to_uint8()</a></code> to convert a string to an 8-bit number, etc.</p>
<p>The other modules (<code>loop</code>, <code>mpool</code>, <code>megawifi</code>) are covered in depth below.</p>
<h2>Loop module</h2>
<p>This module implements the main loop of the program. It allows easily adding and removing functions to be run on the main loop, as well as timers based on the frame counter. It also provides a hacky interface to perform pseudo syncrhonous calls (through the <code><a class="el" href="group__loop.html#ga3fc77f30d1e96e3c6a535cb34fbc5e51" title="This function does not return until a loop_post() is executed.">loop_pend()</a></code> and <code><a class="el" href="group__loop.html#ga68b578220b5354b83cd9ecca21c251ca" title="Causes a previously invoked loop_pend() function to return.">loop_post()</a></code> semantics) without disturbing the loop execution.</p>
<p>A typical Megadrive game contains a main loop with a structure similar to this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Perform initialization</span></div>
<div class="line">    init();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Infinite loop with game logic</span></div>
<div class="line">    <span class="keywordflow">while</span>(1) {</div>
<div class="line">        wait_vblank();</div>
<div class="line">        draw_screen();</div>
<div class="line">        play_sound();</div>
<div class="line">        read_input();</div>
<div class="line">        game_logic();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The game performs the initialization using <code>init()</code> function, and then enters an infinite loop that:</p><ol type="1">
<li>Waits for the vertical blanking period to begin.</li>
<li>Updates the frame (scroll, sprites, tiles, etc).</li>
<li>Keeps the music and SFX playing.</li>
<li>Reads controller inputs.</li>
<li>Computes game logic, such as collision detection, player/enemy movements, etc. When this step finishes, we have all the data to draw the next frame.</li>
</ol>
<p>The order of these elements might be slightly different, but these are the usual suspects in loop game design.</p>
<p>On the contrary, the recommended way to write a MegaWiFi program requires using the <code>loop</code> module to implement the main loop. When using MegaWiFi API, the code above should be written like this (my recommendation with these examples is that you read the code from the bottom function to the top ones):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="util_8h.html">mw/util.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="loop_8h.html">mw/loop.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define MW_MAX_LOOP_FUNCS 2</span></div>
<div class="line"><span class="preprocessor">#define MW_MAX_LOOP_TIMERS 4</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run once per frame</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> frame_cb(<span class="keyword">struct</span> <a class="code" href="structloop__timer.html">loop_timer</a> *t)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Avoid compiler warning because unused t parameter</span></div>
<div class="line">    <a class="code" href="group__util.html#ga6c7ba74ad57863d1342878d2c703e660">UNUSED_PARAM</a>(t);</div>
<div class="line"> </div>
<div class="line">    draw_screen();</div>
<div class="line">    play_sound();</div>
<div class="line">    read_input();</div>
<div class="line">    game_logic();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> main_loop_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structloop__timer.html">loop_timer</a> frame_timer = {</div>
<div class="line">        .<a class="code" href="structloop__timer.html#a49d20719ecda1051ce798021bd1d5c12">timer_cb</a> = frame_cb,</div>
<div class="line">        .frames = 1,</div>
<div class="line">        .auto_reload = <a class="code" href="group__util.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__loop.html#ga40d4c3a2cbefafdbb454f68cdaf9129d">loop_init</a>(MW_MAX_LOOP_FUNCS, MW_MAX_LOOP_TIMERS);</div>
<div class="line">    <a class="code" href="group__loop.html#ga6d6f6f4f4f9ac838b05f02517098f414">loop_timer_add</a>(&amp;frame_timer);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialize game stuff</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize game loop</span></div>
<div class="line">    main_loop_init();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialization</span></div>
<div class="line">    init();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__loop.html#ga4c3a8dbc5064a8e7d9baffbe604216f1">loop</a>();</div>
<div class="line">    <span class="comment">// Function above should never return</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>init()</code> function now calls <code>main_loop_init()</code> to:</p><ol type="1">
<li>Initialize the loop module by calling <code><a class="el" href="group__loop.html#ga40d4c3a2cbefafdbb454f68cdaf9129d" title="Initialize loop.">loop_init()</a></code>.</li>
<li>Add a <em><a class="el" href="structloop__timer.html" title="Loop timer data structure.">loop_timer</a></em> that runs <code>frame_cb()</code> callback once per frame, ideally at the beginning of the vertical blanking period.</li>
</ol>
<p>As <code>frame_cb()</code> is run once per frame, we can (and we <b>must</b>) remove the <code>wait_vblank()</code> function call, and add all the remaining code previously inside the <code>while(1)</code> to the <code>frame_cb()</code>.</p>
<p>Using this module, now if you for example want to add another <em><a class="el" href="structloop__timer.html" title="Loop timer data structure.">loop_timer</a></em> running each 5 frames to update the background animation, you just have to create the callback and the <em><a class="el" href="structloop__timer.html" title="Loop timer data structure.">loop_timer</a></em> structure, to finally add it to the loop by calling <code><a class="el" href="group__loop.html#ga6d6f6f4f4f9ac838b05f02517098f414" title="Add a timer to the loop.">loop_timer_add()</a></code>.</p>
<p>In addition to timers, the module also allows adding functions that are run the spare frame time. We will see this in greater detail when talking about the <code>megawifi</code> module.</p>
<p>The <code>loop</code> module also implements another functionality: pseudo-synchronous event waiting. This eases avoiding the typical callback hell that occurs when coding asynchronous programs. The pseudo-synchronous waits work like this:</p><ol type="1">
<li>The function that wants to wait for an event, calls <code><a class="el" href="group__loop.html#ga3fc77f30d1e96e3c6a535cb34fbc5e51" title="This function does not return until a loop_post() is executed.">loop_pend()</a></code> function. The execution of the function is then suspended.</li>
<li>The suspended function is resumed by doing a <code><a class="el" href="group__loop.html#ga68b578220b5354b83cd9ecca21c251ca" title="Causes a previously invoked loop_pend() function to return.">loop_post()</a></code> call from other point of the code.</li>
</ol>
<p>The important thing to take into account, is that while a function is suspended on a <code><a class="el" href="group__loop.html#ga3fc77f30d1e96e3c6a535cb34fbc5e51" title="This function does not return until a loop_post() is executed.">loop_pend()</a></code> call, the other loop functions and loop timers continue running undisturbed. Isn't this neat?</p>
<p>Nevertheless, you have to be careful when using <code><a class="el" href="group__loop.html#ga3fc77f30d1e96e3c6a535cb34fbc5e51" title="This function does not return until a loop_post() is executed.">loop_pend()</a></code>/<code><a class="el" href="group__loop.html#ga68b578220b5354b83cd9ecca21c251ca" title="Causes a previously invoked loop_pend() function to return.">loop_post()</a></code>: If you nest several <code><a class="el" href="group__loop.html#ga3fc77f30d1e96e3c6a535cb34fbc5e51" title="This function does not return until a loop_post() is executed.">loop_pend()</a></code> calls, the following <code><a class="el" href="group__loop.html#ga68b578220b5354b83cd9ecca21c251ca" title="Causes a previously invoked loop_pend() function to return.">loop_post()</a></code> calls will resume suspended functions in the reverse order of the <code><a class="el" href="group__loop.html#ga3fc77f30d1e96e3c6a535cb34fbc5e51" title="This function does not return until a loop_post() is executed.">loop_pend()</a></code> calls. This is not probably what you want, and thus nesting <code><a class="el" href="group__loop.html#ga3fc77f30d1e96e3c6a535cb34fbc5e51" title="This function does not return until a loop_post() is executed.">loop_pend()</a></code> calls is discouraged unless you know what you are doing.</p>
<p>Also when using the <code>loop</code> module, you have to be careful not to block a loop function or loop timer. These functions must do their task quickly and exit as fast as possible. Otherwise, if you block by polling (e.g waiting for vblank, or waiting for the player to press a button), other loop functions or loop timers will not be able to get any CPU time. The only allowed way to block a loop function or loop timer, is by calling <code><a class="el" href="group__loop.html#ga3fc77f30d1e96e3c6a535cb34fbc5e51" title="This function does not return until a loop_post() is executed.">loop_pend()</a></code> function (or any other function that uses it, such as <code><a class="el" href="group__megawifi.html#gad09542c947defced59a0fe9be0875d06" title="Sleep the specified amount of frames.">mw_sleep()</a></code>.</p>
<p>As using the <code>loop</code> module seems to make the code more complex, maybe you are wondering why bothering with it. We will come to that later.</p>
<h2>Mpool module</h2>
<p>This module implements a very fast and simple memory pool for dynamic memory allocation. Allocated memory is obtained from the unused region between the end of the <code>.bss</code> section and the stack top. The implementation is pretty simple: an internal pointer grows when memory is requested using <code><a class="el" href="group__mpool.html#ga6cd611d9987a2d9dacfdf2b0dce737ad" title="Allocates data from the pool.">mp_alloc()</a></code>, and is reset to the specified position to free memory using <code><a class="el" href="group__mpool.html#gaa587236f548e1a16c90a7981cba57e85" title="Free memory up to the one pointed by pos.">mp_free_to()</a></code>. This restricts the usage of the module to scenarios that free memory in exactly the reverse order in which they requested it (it does not allow generic allocate/free such as <code>malloc()</code> does).</p>
<p>One thing interesting about this module is that you can free the memory allocated by several <code><a class="el" href="group__mpool.html#ga6cd611d9987a2d9dacfdf2b0dce737ad" title="Allocates data from the pool.">mp_alloc()</a></code> calls with a single <code><a class="el" href="group__mpool.html#gaa587236f548e1a16c90a7981cba57e85" title="Free memory up to the one pointed by pos.">mp_free_to()</a></code> call. This behavior can be nasty if you are accustomed to the usual <em>one <code>free()</code> per <code>malloc()</code></em> scheme, but it is sometimes handy. For example, it helps avoiding memory fragmentation and memory leaks when changing from one game level to another. Imagine that you have two game levels and they allocate memory for several structures:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> level1_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>level1_data *l1d = <a class="code" href="group__mpool.html#ga6cd611d9987a2d9dacfdf2b0dce737ad">mp_alloc</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> level1_data));</div>
<div class="line">    <span class="keyword">struct </span>enemy *enem = <a class="code" href="group__mpool.html#ga6cd611d9987a2d9dacfdf2b0dce737ad">mp_alloc</a>(L1_NUM_ENEMIES * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> enemy));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> level2_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>level2_data *l2d = <a class="code" href="group__mpool.html#ga6cd611d9987a2d9dacfdf2b0dce737ad">mp_alloc</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> level2_data));</div>
<div class="line">    <span class="keyword">struct </span>enemy *enem = <a class="code" href="group__mpool.html#ga6cd611d9987a2d9dacfdf2b0dce737ad">mp_alloc</a>(L2_NUM_ENEMIES * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> enemy));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Imagine also that the game allocates more memory during level play for other purposes (bullets, explosions, etc). Now you finish the level and want to make sure all the memory is freed to load the new level. With <code>malloc()</code>/<code>free()</code> you would need to track each allocation and do the corresponding <code>free()</code>. But with the <code>mpool</code> module it is way easier:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> level1_deinit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__mpool.html#gaa587236f548e1a16c90a7981cba57e85">mp_free_to</a>(l1d);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> level2_deinit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__mpool.html#gaa587236f548e1a16c90a7981cba57e85">mp_free_to</a>(l2d);</div>
<div class="line">}</div>
</div><!-- fragment --><p>And that's all, the call to <code>mp_free_to(l1d)</code> will deallocate all the memory obtained since the call to the first <code><a class="el" href="group__mpool.html#ga6cd611d9987a2d9dacfdf2b0dce737ad" title="Allocates data from the pool.">mp_alloc()</a></code> in <code>level1_init()</code>, and you make sure no memory fragmentation and no memory leaks are caused by all the allocations in the level.</p>
<h2>Megawifi module</h2>
<p>And we finally arrive to the <code>megawifi</code> module API. This API allows of course sending and receiving data to/from the Internet, along with some more functions such as:</p>
<ul>
<li>Scanning APs, associating and disassociating to/from them.</li>
<li>Creating both client and server network sockets.</li>
<li>Reading and writing from/to the non-volatile flash memory in the WiFi module.</li>
<li>Keeping the time and day, accurately synchronized to NTP servers.</li>
<li>Generating large amounts of random numbers blazingly fast.</li>
</ul>
<p>You can use this API the hard way (directly sending commands defined in <code>mw-msg</code>), or the easy way (through the API calls in <code>megawifi</code>). Of course the latter is recommended.</p>
<p>Most API functions require sending and receiving data to/from the WiFi module. But the data send/reception is decoupled from the command functions: the API functions prepare the module to send/receive data, but the data is not sent/received until the <code><a class="el" href="group__megawifi.html#ga6ddfe7a25cc8615e4f8de5fe00f7c3f8" title="Processes sends/receives pending data.">mw_process()</a></code> function is called. As the <code><a class="el" href="group__megawifi.html#ga6ddfe7a25cc8615e4f8de5fe00f7c3f8" title="Processes sends/receives pending data.">mw_process()</a></code> function polls the WiFi module for data, it is advisable to run it as frequently as possible. The easiest way to do this, is using a <em><a class="el" href="structloop__func.html" title="Loop function data structure.">loop_func</a></em>. Just set up a <em><a class="el" href="structloop__func.html" title="Loop function data structure.">loop_func</a></em> running <code><a class="el" href="group__megawifi.html#ga6ddfe7a25cc8615e4f8de5fe00f7c3f8" title="Processes sends/receives pending data.">mw_process()</a></code> to ensure this function will be continuously executed, and you're done:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="util_8h.html">mw/util.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="loop_8h.html">mw/loop.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="megawifi_8h.html">mw/megawifi.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> megawifi_loop_cb(<span class="keyword">struct</span> <a class="code" href="structloop__func.html">loop_func</a> *f)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__util.html#ga6c7ba74ad57863d1342878d2c703e660">UNUSED_PARAM</a>(f);</div>
<div class="line">    <a class="code" href="group__megawifi.html#ga6ddfe7a25cc8615e4f8de5fe00f7c3f8">mw_process</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> main_loop_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Loop initialization code</span></div>
<div class="line">    <span class="comment">// [...]</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structloop__func.html">loop_func</a> megawifi_loop = {</div>
<div class="line">        .<a class="code" href="structloop__func.html#a53af751bd25418cdb0791f0068959844">func_cb</a> = megawifi_loop_cb</div>
<div class="line">    };</div>
<div class="line">    <a class="code" href="group__loop.html#ga063359b6f53ca8e491c41807cd4d5760">loop_func_add</a>(&amp;megawifi_loop);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using a <em><a class="el" href="structloop__func.html" title="Loop function data structure.">loop_func</a></em> like this makes sending and receiving data during game idle time way easier. Just make sure you set up your loops properly, and leave a bit of time for the loop function running <code><a class="el" href="group__megawifi.html#ga6ddfe7a25cc8615e4f8de5fe00f7c3f8" title="Processes sends/receives pending data.">mw_process()</a></code>. Otherwise this function will starve and no data will be sent/received!</p>
<p>About the API calls, basically all of them are synchronous or pseudo-synchronous, excepting the following ones, that are asynchronous and use callbacks to signal task completion:</p>
<ul>
<li><code><a class="el" href="group__megawifi.html#gab99864c90151e2bffe5d685cd6e1b241" title="Sends data through a socket, using a previously allocated channel. Asynchronous interface.">mw_send()</a></code>: Send data to the other socket end.</li>
<li><code><a class="el" href="group__megawifi.html#ga8227c5ef923c4eee7f978ccf80cff9af" title="Receive data, asyncrhonous interface.">mw_recv()</a></code>: Receive data from the other socket end.</li>
<li><code><a class="el" href="group__megawifi.html#ga79e05a128d08dce3df5f444a3b9af88b" title="Send a command to the WiFi module.">mw_cmd_send()</a></code>: Send a command to the WiFi module.</li>
<li><code><a class="el" href="group__megawifi.html#gae296015ee73ae119ae763bdae9839a60" title="Try obtaining a reply to a command.">mw_cmd_recv()</a></code>: Receive a command reply from the WiFi module.</li>
</ul>
<p>Usually <code><a class="el" href="group__megawifi.html#ga79e05a128d08dce3df5f444a3b9af88b" title="Send a command to the WiFi module.">mw_cmd_send()</a></code> and <code><a class="el" href="group__megawifi.html#gae296015ee73ae119ae763bdae9839a60" title="Try obtaining a reply to a command.">mw_cmd_recv()</a></code> are not needed unless you decide to go down the hard path (using <code>mw-msg</code> to build commands yourself). For sending/receiving data, it's up to you using the asynchronous <code><a class="el" href="group__megawifi.html#gab99864c90151e2bffe5d685cd6e1b241" title="Sends data through a socket, using a previously allocated channel. Asynchronous interface.">mw_send()</a></code> and <code><a class="el" href="group__megawifi.html#ga8227c5ef923c4eee7f978ccf80cff9af" title="Receive data, asyncrhonous interface.">mw_recv()</a></code> or their pseudo-synchronous counterparts <code><a class="el" href="group__megawifi.html#gad8a3660c1dda462ca37ac3cb1a61e347" title="Sends data through a socket, using a previously allocated channel. Synchronous interface.">mw_send_sync()</a></code> and <code><a class="el" href="group__megawifi.html#ga8eae5109b67bbc7d238fc17e9ad02ee7" title="Receive data, syncrhonous interface.">mw_recv_sync()</a></code>.</p>
<p>To save precious RAM, command functions reuse the same buffer. Thus when a command reply is obtained, you have to copy the needed data from the buffer before issuing another command. Otherwise the data in the previously received buffer will be lost.</p>
<h1>Putting all together</h1>
<p>In this section several examples explaining how to code typical tasks are presented.</p>
<h2>Connection configuration</h2>
<p>MegaWiFi modules have 3 configuration slots, allowing to store 3 different network configurations. The configuration parameters are:</p>
<ul>
<li>Access point configuration (SSID, password), using <code><a class="el" href="group__megawifi.html#ga358c077f1c80fd5ee497208b5d691115" title="Set access point configuration (SSID and password).">mw_ap_cfg_set()</a></code>. This usually requires a previous AP scan using <code><a class="el" href="group__megawifi.html#gaf961d3319d6218008b48450d658c733b" title="Scan for access points.">mw_ap_scan()</a></code> and cycling through scan results using <code><a class="el" href="group__megawifi.html#ga2cd98705a48c59d7710b29223ce2b917" title="Parses received AP data and fills information of the AP at &quot;pos&quot;. Useful to extract AP information fr...">mw_ap_fill_next()</a></code>.</li>
<li>IP configuration, using <code><a class="el" href="group__megawifi.html#ga1880676a5f5fdc3119e4e00867cabb4b" title="Set IPv4 configuration.">mw_ip_cfg_set()</a></code>. Both automatic (DHCP) and manual configurations are supported.</li>
</ul>
<p>The good news is that you do not need to code the connection configuration, you can use the <a href="https://github.com/doragasu/mw-wflash/">wflash bootloader</a> to configure the network. As the configuration is stored inside the module, you can use it from your game, even if you delete the wflash bootloader ROM from the MegaWiFi cartridge.</p>
<h2>Program initialization</h2>
<p>Basically you have to initialize megawifi and the game loop as explained before. You also have to create a <em><a class="el" href="structloop__func.html" title="Loop function data structure.">loop_func</a></em> to run <code><a class="el" href="group__megawifi.html#ga6ddfe7a25cc8615e4f8de5fe00f7c3f8" title="Processes sends/receives pending data.">mw_process()</a></code> and a <em><a class="el" href="structloop__timer.html" title="Loop timer data structure.">loop_timer</a></em> with a 1 frame period to handle the game loop. The code below shows how to do this, and also how to detect if the WiFi module is installed, along with its firmware version.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="util_8h.html">mw/util.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mpool_8h.html">mw/mpool.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="loop_8h.html">mw/loop.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="megawifi_8h.html">mw/megawifi.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Length of the wflash buffer</span></div>
<div class="line"><span class="preprocessor">#define MW_BUFLEN   1440</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// TCP port to use (set to Megadrive release year ;-)</span></div>
<div class="line"><span class="preprocessor">#define MW_CH_PORT  1985</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Maximum number of loop functions</span></div>
<div class="line"><span class="preprocessor">#define MW_MAX_LOOP_FUNCS   2</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Maximun number of loop timers</span></div>
<div class="line"><span class="preprocessor">#define MW_MAX_LOOP_TIMERS  4</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Command buffer</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> cmd_buf[MW_BUFLEN];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Runs mw_process() during idle time</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> idle_cb(<span class="keyword">struct</span> <a class="code" href="structloop__func.html">loop_func</a> *f)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__util.html#ga6c7ba74ad57863d1342878d2c703e660">UNUSED_PARAM</a>(f);</div>
<div class="line">    <a class="code" href="group__megawifi.html#ga6ddfe7a25cc8615e4f8de5fe00f7c3f8">mw_process</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// MegaWiFi initialization</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> megawifi_init_cb(<span class="keyword">struct</span> <a class="code" href="structloop__func.html">loop_func</a>  *f)</div>
<div class="line">{</div>
<div class="line">    uint8_t ver_major = 0, ver_minor = 0;</div>
<div class="line">    <span class="keywordtype">char</span> *variant = <a class="code" href="group__util.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    <span class="keyword">enum</span> <a class="code" href="group__megawifi.html#ga777c2b3caa535d405278734b0f5aad2e">mw_err</a> err;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// megawifi_init_cb is run only once. Use idle_cb from now on</span></div>
<div class="line">    f-&gt;<a class="code" href="structloop__func.html#a53af751bd25418cdb0791f0068959844">func_cb</a> = idle_cb;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize MegaWiFi</span></div>
<div class="line">    <a class="code" href="group__megawifi.html#ga50526e0ea48208cd7ce658408e6777ab">mw_init</a>(cmd_buf, MW_BUFLEN);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Try detecting the module</span></div>
<div class="line">    err = <a class="code" href="group__megawifi.html#ga582e7d40df5994a7c11b24ace5bbe881">mw_detect</a>(&amp;ver_major, &amp;ver_minor, &amp;variant);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a> != err) {</div>
<div class="line">        <span class="comment">// Megawifi cart not found!</span></div>
<div class="line">        <span class="comment">// [...]</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// MegaWiFi found!</span></div>
<div class="line">        <span class="comment">// [...]</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run the game loop once per frame</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> frame_cb(<span class="keyword">struct</span> <a class="code" href="structloop__timer.html">loop_timer</a> *t)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__util.html#ga6c7ba74ad57863d1342878d2c703e660">UNUSED_PARAM</a>(t);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// One iteration of game loop</span></div>
<div class="line">    draw_screen();</div>
<div class="line">    play_sound();</div>
<div class="line">    read_input();</div>
<div class="line">    game_logic();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Loop initialization</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> main_loop_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structloop__timer.html">loop_timer</a> frame_timer = {</div>
<div class="line">        .<a class="code" href="structloop__timer.html#a49d20719ecda1051ce798021bd1d5c12">timer_cb</a> = frame_cb,</div>
<div class="line">        .frames = 1,</div>
<div class="line">        .auto_reload = <a class="code" href="group__util.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structloop__func.html">loop_func</a> megawifi_loop = {</div>
<div class="line">        .<a class="code" href="structloop__func.html#a53af751bd25418cdb0791f0068959844">func_cb</a> = megawifi_init_cb</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__loop.html#ga40d4c3a2cbefafdbb454f68cdaf9129d">loop_init</a>(MW_MAX_LOOP_FUNCS, MW_MAX_LOOP_TIMERS);</div>
<div class="line">    <a class="code" href="group__loop.html#ga6d6f6f4f4f9ac838b05f02517098f414">loop_timer_add</a>(&amp;frame_timer);</div>
<div class="line">    <a class="code" href="group__loop.html#ga063359b6f53ca8e491c41807cd4d5760">loop_func_add</a>(&amp;megawifi_loop);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Global initialization</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialize hardware and game</span></div>
<div class="line">    <span class="comment">// [...]</span></div>
<div class="line">    <span class="comment">// Initialize memory pool</span></div>
<div class="line">    <a class="code" href="group__mpool.html#gae1b6b14b314e5aedcb6dadcc889c4cec">mp_init</a>(0);</div>
<div class="line">    <span class="comment">// Initialize game loop</span></div>
<div class="line">    main_loop_init();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialization</span></div>
<div class="line">    init();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__loop.html#ga4c3a8dbc5064a8e7d9baffbe604216f1">loop</a>();</div>
<div class="line">    <span class="comment">// loop() should never return</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Associating to an AP</h2>
<p>Once configured, associating to an AP is easy. Just call <code><a class="el" href="group__megawifi.html#ga2a3299d2d6e2480b714ba880024ab59e" title="Tries associating to an AP. If successful, also configures IPv4.">mw_ap_assoc()</a></code> with the desired configuration slot, and the module will start the process. You can wait until the association is successful or fails (because of timeout) by calling <code><a class="el" href="group__megawifi.html#gab71427cc580c31e355d36eca5e4ab9c4" title="Polls the module status until it reports device is associated to AP or timeout occurs.">mw_ap_assoc_wait()</a></code>. The following code tries to associate to an AP during 30 seconds (<em>fps</em> must be set previously to 60 on NTSC machines or 50 on PAL machines).</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="group__megawifi.html#ga777c2b3caa535d405278734b0f5aad2e">mw_err</a> err;</div>
<div class="line"> </div>
<div class="line">err = <a class="code" href="group__megawifi.html#ga2a3299d2d6e2480b714ba880024ab59e">mw_ap_assoc</a>(slot);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a> == err) {</div>
<div class="line">    err = <a class="code" href="group__megawifi.html#gab71427cc580c31e355d36eca5e4ab9c4">mw_ap_assoc_wait</a>(30 * fps);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a> == err) {</div>
<div class="line">    <span class="comment">// Association succeeded</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Association failed</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Once association has succeeded, you can try connecting to a server, or creating a server socket. DNS service will also start automatically after associating to the AP, but it takes a little bit more time. So if you need to use DNS just after associating to an AP, you should wait an additional second, e.g. by calling <code>mw_sleep(MS_TO_FRAMES(1000))</code>.</p>
<h2>Connecting to a TCP server</h2>
<p>Connecting to a server is straightforward: just call <code><a class="el" href="group__megawifi.html#gaaf6aaaa928b6085b6ecf7012e2c6aa1b" title="Tries establishing a TCP connection with specified server.">mw_tcp_connect()</a></code> with the channel to use, the destination address (both IPv4 addresses and domain names are supported), the destination port, and optionally the origin port (if NULL, it will be automatically set):</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="group__megawifi.html#ga777c2b3caa535d405278734b0f5aad2e">mw_err</a> err;</div>
<div class="line"> </div>
<div class="line">err = <a class="code" href="group__megawifi.html#gaaf6aaaa928b6085b6ecf7012e2c6aa1b">mw_tcp_connect</a>(1, <span class="stringliteral">&quot;www.duck.com&quot;</span>, <span class="stringliteral">&quot;443&quot;</span>, <a class="code" href="group__util.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a> == err) {</div>
<div class="line">    <span class="comment">// Connection succeeded</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Connection failed</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Once connected, you can start sending and receiving data. When no longer needed, remember to close the connection with <code><a class="el" href="group__megawifi.html#ga1fba45bbaeb37503895f2261ea23a954" title="Closes a TCP socket. This is an alias of mw_close().">mw_tcp_disconnect()</a></code>. The channel number must be from 1 to <code>LSD_MAX_CH</code> (usually 4). The used channel number will be passed to all the calls relative to the connected socket (think about it like a socket number).</p>
<h2>Creating a TCP server socket</h2>
<p>Creating a TCP server socket requires binding it to a port, using <code><a class="el" href="group__megawifi.html#ga82f774de9f50b730de578cb0e7512d16" title="Binds a socket to a port, and listens to connections on the port. If a connection request is received...">mw_tcp_bind()</a></code>. After this, MegaWiFi will automatically accept any incoming connection on this port. You can check when the connection has been established by calling <code><a class="el" href="group__megawifi.html#ga0f4fd1409dc625d7506960f09ddccef5" title="Polls a socket until it is ready to transfer data. Typical use of this function is after a successful...">mw_sock_conn_wait()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="group__megawifi.html#ga777c2b3caa535d405278734b0f5aad2e">mw_err</a> err;</div>
<div class="line"> </div>
<div class="line">err = <a class="code" href="group__megawifi.html#ga82f774de9f50b730de578cb0e7512d16">mw_tcp_bind</a>(1, 1985);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a> == err) {</div>
<div class="line">    <span class="comment">// Wait up to an hour for an incoming connection</span></div>
<div class="line">    err = <a class="code" href="group__megawifi.html#ga0f4fd1409dc625d7506960f09ddccef5">mw_sock_conn_wait</a>(1, 60 * 60 * fps);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a> == err) {</div>
<div class="line">    <span class="comment">// Incoming connection established</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Timeout, no connection established</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Sending data</h2>
<p>You can send data once a connection has been established. The easiest way is using the synchronous variant, but as it suspends the execution of the calling function until data is sent, sometimes the asynchronous version is more convenient. The following code shows how to send <em>data</em> buffer of <em>data_length</em> length using channel 1, with a two second timeout:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="group__megawifi.html#ga777c2b3caa535d405278734b0f5aad2e">mw_err</a> err;</div>
<div class="line"> </div>
<div class="line">err = <a class="code" href="group__megawifi.html#gad8a3660c1dda462ca37ac3cb1a61e347">mw_send_sync</a>(1, data, data_length, 2 * fps);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a> == err) {</div>
<div class="line">    <span class="comment">// Data sent</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Timeout, data was not sent</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The same data can be sent this way using the asynchronous API:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> send_complete_cb(<span class="keyword">enum</span> lsd_status stat, <span class="keywordtype">void</span> *ctx)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__util.html#ga6c7ba74ad57863d1342878d2c703e660">UNUSED_PARAM</a>(ctx);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (LSD_STAT_COMPLETE == stat) {</div>
<div class="line">        <span class="comment">// Data successfully sent</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Sending data failed</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> send_example(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">enum</span> lsd_status stat;</div>
<div class="line"> </div>
<div class="line">    stat = <a class="code" href="group__megawifi.html#gab99864c90151e2bffe5d685cd6e1b241">mw_send</a>(1, data, data_length, <a class="code" href="group__util.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, send_complete_cb);</div>
<div class="line">    <span class="keywordflow">if</span> (stat &lt; 0) {</div>
<div class="line">        <span class="comment">// Sending failed</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>When using the asynchronous API, sometimes you do not need confirmation about when data has been sent. In that case, you do not need to use a completion callback, and can call <code><a class="el" href="group__megawifi.html#gab99864c90151e2bffe5d685cd6e1b241" title="Sends data through a socket, using a previously allocated channel. Asynchronous interface.">mw_send()</a></code> with this parameter set to NULL.</p>
<h2>Receiving data</h2>
<p>You can receive data once a connection has been established. The easiest way is using the synchronous variant, but as it suspends the execution of the calling function until data is received, sometimes the asynchronous version is more convenient. The following code shows how to receive <em>data</em> buffer of <em>buf_length</em> maximum length using channel 1, with a 30 second timeout:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="group__megawifi.html#ga777c2b3caa535d405278734b0f5aad2e">mw_err</a> err;</div>
<div class="line"> </div>
<div class="line">err = <a class="code" href="group__megawifi.html#ga8eae5109b67bbc7d238fc17e9ad02ee7">mw_recv_sync</a>(1, data, &amp;buf_length, 30 * fps);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a> == err) {</div>
<div class="line">    <span class="comment">// Data received</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Failed to receive data</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that when the function successfully returns, <em>buf_length</em> contains the number of bytes received.</p>
<p>The same data can be received this way using the asynchronous API:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> recv_complete_cb(<span class="keyword">enum</span> lsd_status stat, uint8_t ch, <span class="keywordtype">char</span> *data,</div>
<div class="line">            uint16_t len, <span class="keywordtype">void</span> *ctx)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__util.html#ga6c7ba74ad57863d1342878d2c703e660">UNUSED_PARAM</a>(ctx);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (LSD_STAT_COMPLETE == stat) {</div>
<div class="line">        <span class="comment">// Data successfully received</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Data reception failed</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recv_example(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">enum</span> lsd_status stat;</div>
<div class="line"> </div>
<div class="line">    stat = <a class="code" href="group__megawifi.html#ga8227c5ef923c4eee7f978ccf80cff9af">mw_recv</a>(data, data_length, <a class="code" href="group__util.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, recv_complete_cb);</div>
<div class="line">    <span class="keywordflow">if</span> (stat &lt; 0) {</div>
<div class="line">        <span class="comment">// Reception failed</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Data will be received by mw_process()</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Getting the date and time</h2>
<p>MegaWiFi allows to synchronize the date and time to NTP servers. It is important to note that on console power up, the module date and time will be incorrect and should not be used. For the date and time to be synchronized, the module must be associated to an AP with Internet connectivity. Once associated, the date and time is automatically synchronized. The synchronization procedure usually takes only a few seconds, and once completed, date/time should be usable until the console is powered off.</p>
<p>To know if the date and time is in sync, you can use the <code><a class="el" href="group__megawifi.html#gaef95cf26f3656a8ac958475c618569b0" title="Get system status.">mw_sys_stat_get()</a></code> command:</p>
<div class="fragment"><div class="line"><span class="keyword">union </span><a class="code" href="unionmw__msg__sys__stat.html">mw_msg_sys_stat</a> *<a class="code" href="unionmw__msg__sys__stat.html#a1e0225d35341fd30ae96f0c799233df4">sys_stat</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="unionmw__msg__sys__stat.html#a1e0225d35341fd30ae96f0c799233df4">sys_stat</a> = <a class="code" href="group__megawifi.html#gaef95cf26f3656a8ac958475c618569b0">mw_sys_stat_get</a>();</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="unionmw__msg__sys__stat.html#a1e0225d35341fd30ae96f0c799233df4">sys_stat</a> &amp;&amp; <a class="code" href="unionmw__msg__sys__stat.html#a1e0225d35341fd30ae96f0c799233df4">sys_stat</a>-&gt;dt_ok) {</div>
<div class="line">    <span class="comment">// Date and time syncrhonized</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Date and time **not** synchronized, or other error</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Once date and time is synchronized, you can get it, both in human readable format, and in the number of seconds elapsed since the epoch, with a single call to <code><a class="el" href="group__megawifi.html#ga9eb5082f2dc47b0c802ba6dc233ada4e" title="Get date and time.">mw_date_time_get()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *date_time_string;</div>
<div class="line">uint32_t date_time_bin[2];</div>
<div class="line"> </div>
<div class="line">date_time_string = <a class="code" href="group__megawifi.html#ga9eb5082f2dc47b0c802ba6dc233ada4e">mw_date_time_get</a>(date_time_bin);</div>
</div><!-- fragment --><h2>Setting and getting gamertag information</h2>
<p>MegaWiFi API allows to store and retrieve up to 3 gamertags. The gamertag information is contained in the <em><a class="el" href="structmw__gamertag.html" title="Gamertag data.">mw_gamertag</a></em> structure. This structure holds the gamertag unique identifier, nickname, security credentials (password) and a 32x48 avatar (tile information and palette). This example shows how to set a gamertag (excepting the graphics data):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> gamertag_set(<span class="keywordtype">int</span> slot, <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> *security, <span class="keyword">const</span> <span class="keywordtype">char</span> *tagline)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="structmw__gamertag.html">mw_gamertag</a> gamertag = {};</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="group__megawifi.html#ga777c2b3caa535d405278734b0f5aad2e">mw_err</a> err;</div>
<div class="line"> </div>
<div class="line">    gamertag.<a class="code" href="structmw__gamertag.html#a4d1622737aa1ef49b5cda6c93e3d1036">id</a> = id;</div>
<div class="line">    strcpy(gamertag.<a class="code" href="structmw__gamertag.html#ad126e84a77ac1dc74d03b94d1c3f402c">nickname</a>, name);</div>
<div class="line">    strcpy(gamertag.<a class="code" href="structmw__gamertag.html#ab0931be9019b21951e3fe40f86d52243">security</a>, security);</div>
<div class="line">    strcpy(gamertag.<a class="code" href="structmw__gamertag.html#aef2019230d62535a3035a02853790e0d">tagline</a>, tagline);</div>
<div class="line"> </div>
<div class="line">    err = <a class="code" href="group__megawifi.html#ga9ab26dbe9fc804915a4f8b5db4e194ed">mw_gamertag_set</a>(slot, &amp;gamertag);</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a> == err) {</div>
<div class="line">        <span class="comment">// Gamertag set successfully</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Setting gamertag failed</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>To read the gamertag, just call <code><a class="el" href="group__megawifi.html#ga635b2e45820d9872badae382a7730153" title="Get gamertag information for one slot.">mw_gamertag_get()</a></code> function, and the information corresponding to the requested slot will be returned:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structmw__gamertag.html">mw_gamertag</a> *gamertag = <a class="code" href="group__megawifi.html#ga635b2e45820d9872badae382a7730153">mw_gamertag_get</a>(slot);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!gamertag) {</div>
<div class="line">    <span class="comment">// Something went wrong</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Success!</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Reading the module BSSIDs</h2>
<p>The module has two network interfaces, each one with its unique BSSID (MAC address). One interface is used for the station mode, while the other is for the AP mode. Each BSSID is 6-byte long. Currently the API does not allow using the AP mode, so to get the station mode BSSID you can do as follows:</p>
<div class="fragment"><div class="line">uint8_t *bssid = <a class="code" href="group__megawifi.html#gabcab943ad7996de14e41a669a369d2b6">mw_bssid_get</a>(<a class="code" href="group__megawifi.html#ggaa395ab95fb1639b3faea74217972dda9a913ca58caf0372816e9499fa366f1ebb">MW_IF_STATION</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!bssid) {</div>
<div class="line">    <span class="comment">// Something went wrong</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Success! You can use bssid[0] through bssid[5]</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Reading and writing to non-volatile Flash</h2>
<p>In addition to the standard 32 megabits of Flash ROM memory connected to the Megadrive 68k bus, MegaWiFi cartridges have 28 megabits of additional flash storage, directly usable by the game. This memory is organized in 4 KiB sectors, and supports the following operations:</p>
<ul>
<li>Identify: call <code><a class="el" href="group__megawifi.html#ga2576a203dfae25cead3a44954ee60d91" title="Get date and time.">mw_flash_id_get()</a></code> to obtain the flash memory identifiers. Usually not needed.</li>
<li>Erase: call <code><a class="el" href="group__megawifi.html#ga35f6a09aa3ecd86e5327521a2a7f41c6" title="Erase a 4 KiB Flash sector. Every byte of an erased sector will be read as 0xFF.">mw_flash_sector_erase()</a></code> to erase an entire 4 KiB sector. Erased sectors will be read as 0xFF.</li>
<li>Program: call <code><a class="el" href="group__megawifi.html#gad2c3c09a3e99be8893cba9ad867fc4e9" title="Write data to specified flash address.">mw_flash_write()</a></code> to write the specified data buffer to the indicated address. Prior to programming, <b>make sure the programmed address range is previously erased</b>, otherwise operation will fail.</li>
<li>Read: call <code><a class="el" href="group__megawifi.html#gae2183be207f9ef7fa2c14932aa87269d" title="Read data from specified flash address.">mw_flash_read()</a></code> to read the specified amount of data from the indicated address.</li>
</ul>
<p>This functions can be used e.g. for highscore keeping or DLCs. When using these functions, you have to keep in mind that flash can only be erased in a 1 sector (i.e. 4 KiB) granularity, and thus if e.g. you want to keep highscores, to update one of the high scores, you will have to erase the complete sector, and write it again in its entirety.</p>
<p>Also keep in mind that flash memory suffers from wearing, so do not perform more writes than necessary.</p>
<h2>Test program</h2>
<p>The main.c file contains a test program that detects the WiFi module, associates to the AP on slot 0, and tries connecting to <code>www.duck.com</code> on port 443.</p>
<h1>Author</h1>
<p>This API and documentation has been written by Jess Alonso (doragasu).</p>
<h1>Contributions</h1>
<p>Contributions are welcome. If you find a bug please open an issue, and if you have implemented a cool feature/improvement, please send a pull request.</p>
<h1>License</h1>
<p>This program is provided with NO WARRANTY, under the <a href="https://www.mozilla.org/en-US/MPL/">Mozilla Public License (MPL)</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__megawifi_html_gad8a3660c1dda462ca37ac3cb1a61e347"><div class="ttname"><a href="group__megawifi.html#gad8a3660c1dda462ca37ac3cb1a61e347">mw_send_sync</a></div><div class="ttdeci">enum mw_err mw_send_sync(uint8_t ch, const char *data, uint16_t len, uint16_t tout_frames)</div><div class="ttdoc">Sends data through a socket, using a previously allocated channel. Synchronous interface.</div></div>
<div class="ttc" id="agroup__loop_html_ga6d6f6f4f4f9ac838b05f02517098f414"><div class="ttname"><a href="group__loop.html#ga6d6f6f4f4f9ac838b05f02517098f414">loop_timer_add</a></div><div class="ttdeci">int loop_timer_add(struct loop_timer *timer)</div><div class="ttdoc">Add a timer to the loop.</div></div>
<div class="ttc" id="aunionmw__msg__sys__stat_html"><div class="ttname"><a href="unionmw__msg__sys__stat.html">mw_msg_sys_stat</a></div><div class="ttdoc">System status.</div><div class="ttdef"><b>Definition:</b> <a href="mw-msg_8h_source.html#l00232">mw-msg.h:232</a></div></div>
<div class="ttc" id="agroup__megawifi_html_ga9ab26dbe9fc804915a4f8b5db4e194ed"><div class="ttname"><a href="group__megawifi.html#ga9ab26dbe9fc804915a4f8b5db4e194ed">mw_gamertag_set</a></div><div class="ttdeci">enum mw_err mw_gamertag_set(uint8_t slot, const struct mw_gamertag *gamertag)</div><div class="ttdoc">Set gamertag information for one slot.</div></div>
<div class="ttc" id="agroup__megawifi_html_ga2a3299d2d6e2480b714ba880024ab59e"><div class="ttname"><a href="group__megawifi.html#ga2a3299d2d6e2480b714ba880024ab59e">mw_ap_assoc</a></div><div class="ttdeci">enum mw_err mw_ap_assoc(uint8_t slot)</div><div class="ttdoc">Tries associating to an AP. If successful, also configures IPv4.</div></div>
<div class="ttc" id="agroup__util_html_ga070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="group__util.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdoc">NULL Pointer.</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00029">util.h:29</a></div></div>
<div class="ttc" id="agroup__megawifi_html_ga9eb5082f2dc47b0c802ba6dc233ada4e"><div class="ttname"><a href="group__megawifi.html#ga9eb5082f2dc47b0c802ba6dc233ada4e">mw_date_time_get</a></div><div class="ttdeci">char * mw_date_time_get(uint32_t dt_bin[2])</div><div class="ttdoc">Get date and time.</div></div>
<div class="ttc" id="agroup__megawifi_html_gab99864c90151e2bffe5d685cd6e1b241"><div class="ttname"><a href="group__megawifi.html#gab99864c90151e2bffe5d685cd6e1b241">mw_send</a></div><div class="ttdeci">static enum lsd_status mw_send(uint8_t ch, const char *data, int16_t len, void *ctx, lsd_send_cb send_cb)</div><div class="ttdoc">Sends data through a socket, using a previously allocated channel. Asynchronous interface.</div><div class="ttdef"><b>Definition:</b> <a href="megawifi_8h_source.html#l00473">megawifi.h:473</a></div></div>
<div class="ttc" id="agroup__megawifi_html_ga6ddfe7a25cc8615e4f8de5fe00f7c3f8"><div class="ttname"><a href="group__megawifi.html#ga6ddfe7a25cc8615e4f8de5fe00f7c3f8">mw_process</a></div><div class="ttdeci">static void mw_process(void)</div><div class="ttdoc">Processes sends/receives pending data.</div><div class="ttdef"><b>Definition:</b> <a href="megawifi_8h_source.html#l00140">megawifi.h:140</a></div></div>
<div class="ttc" id="amegawifi_8h_html"><div class="ttname"><a href="megawifi_8h.html">megawifi.h</a></div><div class="ttdoc">MegaWiFi API implementation.</div></div>
<div class="ttc" id="agroup__megawifi_html_gaef95cf26f3656a8ac958475c618569b0"><div class="ttname"><a href="group__megawifi.html#gaef95cf26f3656a8ac958475c618569b0">mw_sys_stat_get</a></div><div class="ttdeci">union mw_msg_sys_stat * mw_sys_stat_get(void)</div><div class="ttdoc">Get system status.</div></div>
<div class="ttc" id="agroup__megawifi_html_ga582e7d40df5994a7c11b24ace5bbe881"><div class="ttname"><a href="group__megawifi.html#ga582e7d40df5994a7c11b24ace5bbe881">mw_detect</a></div><div class="ttdeci">enum mw_err mw_detect(uint8_t *major, uint8_t *minor, char **variant)</div><div class="ttdoc">Performs the startup sequence for the WiFi module, and tries detecting it by requesting the version d...</div></div>
<div class="ttc" id="agroup__util_html_ga6c7ba74ad57863d1342878d2c703e660"><div class="ttname"><a href="group__util.html#ga6c7ba74ad57863d1342878d2c703e660">UNUSED_PARAM</a></div><div class="ttdeci">#define UNUSED_PARAM(x)</div><div class="ttdoc">Remove compiler warnings when not using a function parameter.</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00055">util.h:55</a></div></div>
<div class="ttc" id="agroup__megawifi_html_gabcab943ad7996de14e41a669a369d2b6"><div class="ttname"><a href="group__megawifi.html#gabcab943ad7996de14e41a669a369d2b6">mw_bssid_get</a></div><div class="ttdeci">uint8_t * mw_bssid_get(enum mw_if_type interface_type)</div><div class="ttdoc">Gets the module BSSID (the MAC address) for the specified interface.</div></div>
<div class="ttc" id="astructmw__gamertag_html_aef2019230d62535a3035a02853790e0d"><div class="ttname"><a href="structmw__gamertag.html#aef2019230d62535a3035a02853790e0d">mw_gamertag::tagline</a></div><div class="ttdeci">char tagline[MW_GT_TAGLINE_MAX]</div><div class="ttdoc">User defined text tag.</div><div class="ttdef"><b>Definition:</b> <a href="mw-msg_8h_source.html#l00198">mw-msg.h:198</a></div></div>
<div class="ttc" id="astructloop__timer_html_a49d20719ecda1051ce798021bd1d5c12"><div class="ttname"><a href="structloop__timer.html#a49d20719ecda1051ce798021bd1d5c12">loop_timer::timer_cb</a></div><div class="ttdeci">loop_timer_cb timer_cb</div><div class="ttdoc">Timer callback function.</div><div class="ttdef"><b>Definition:</b> <a href="loop_8h_source.html#l00060">loop.h:60</a></div></div>
<div class="ttc" id="agroup__megawifi_html_ga8eae5109b67bbc7d238fc17e9ad02ee7"><div class="ttname"><a href="group__megawifi.html#ga8eae5109b67bbc7d238fc17e9ad02ee7">mw_recv_sync</a></div><div class="ttdeci">enum mw_err mw_recv_sync(uint8_t *ch, char *buf, int16_t *buf_len, uint16_t tout_frames)</div><div class="ttdoc">Receive data, syncrhonous interface.</div></div>
<div class="ttc" id="aunionmw__msg__sys__stat_html_a1e0225d35341fd30ae96f0c799233df4"><div class="ttname"><a href="unionmw__msg__sys__stat.html#a1e0225d35341fd30ae96f0c799233df4">mw_msg_sys_stat::sys_stat</a></div><div class="ttdeci">enum mw_state sys_stat</div><div class="ttdoc">System status.</div><div class="ttdef"><b>Definition:</b> <a href="mw-msg_8h_source.html#l00235">mw-msg.h:235</a></div></div>
<div class="ttc" id="astructmw__gamertag_html"><div class="ttname"><a href="structmw__gamertag.html">mw_gamertag</a></div><div class="ttdoc">Gamertag data.</div><div class="ttdef"><b>Definition:</b> <a href="mw-msg_8h_source.html#l00190">mw-msg.h:190</a></div></div>
<div class="ttc" id="astructmw__gamertag_html_ab0931be9019b21951e3fe40f86d52243"><div class="ttname"><a href="structmw__gamertag.html#ab0931be9019b21951e3fe40f86d52243">mw_gamertag::security</a></div><div class="ttdeci">char security[MW_GT_SECURITY_MAX]</div><div class="ttdoc">User security string.</div><div class="ttdef"><b>Definition:</b> <a href="mw-msg_8h_source.html#l00196">mw-msg.h:196</a></div></div>
<div class="ttc" id="astructmw__gamertag_html_ad126e84a77ac1dc74d03b94d1c3f402c"><div class="ttname"><a href="structmw__gamertag.html#ad126e84a77ac1dc74d03b94d1c3f402c">mw_gamertag::nickname</a></div><div class="ttdeci">char nickname[MW_GT_NICKNAME_MAX]</div><div class="ttdoc">User nickname.</div><div class="ttdef"><b>Definition:</b> <a href="mw-msg_8h_source.html#l00194">mw-msg.h:194</a></div></div>
<div class="ttc" id="agroup__mpool_html_gae1b6b14b314e5aedcb6dadcc889c4cec"><div class="ttname"><a href="group__mpool.html#gae1b6b14b314e5aedcb6dadcc889c4cec">mp_init</a></div><div class="ttdeci">void mp_init(int force_init)</div><div class="ttdoc">Pool initialization.</div></div>
<div class="ttc" id="agroup__megawifi_html_gaaf6aaaa928b6085b6ecf7012e2c6aa1b"><div class="ttname"><a href="group__megawifi.html#gaaf6aaaa928b6085b6ecf7012e2c6aa1b">mw_tcp_connect</a></div><div class="ttdeci">enum mw_err mw_tcp_connect(uint8_t ch, const char *dst_addr, const char *dst_port, const char *src_port)</div><div class="ttdoc">Tries establishing a TCP connection with specified server.</div></div>
<div class="ttc" id="agroup__loop_html_ga40d4c3a2cbefafdbb454f68cdaf9129d"><div class="ttname"><a href="group__loop.html#ga40d4c3a2cbefafdbb454f68cdaf9129d">loop_init</a></div><div class="ttdeci">int loop_init(uint8_t max_func, uint8_t max_timer)</div><div class="ttdoc">Initialize loop.</div></div>
<div class="ttc" id="agroup__mpool_html_gaa587236f548e1a16c90a7981cba57e85"><div class="ttname"><a href="group__mpool.html#gaa587236f548e1a16c90a7981cba57e85">mp_free_to</a></div><div class="ttdeci">void mp_free_to(void *pos)</div><div class="ttdoc">Free memory up to the one pointed by pos.</div></div>
<div class="ttc" id="agroup__megawifi_html_ga0f4fd1409dc625d7506960f09ddccef5"><div class="ttname"><a href="group__megawifi.html#ga0f4fd1409dc625d7506960f09ddccef5">mw_sock_conn_wait</a></div><div class="ttdeci">enum mw_err mw_sock_conn_wait(uint8_t ch, int tout_frames)</div><div class="ttdoc">Polls a socket until it is ready to transfer data. Typical use of this function is after a successful...</div></div>
<div class="ttc" id="agroup__megawifi_html_ga50526e0ea48208cd7ce658408e6777ab"><div class="ttname"><a href="group__megawifi.html#ga50526e0ea48208cd7ce658408e6777ab">mw_init</a></div><div class="ttdeci">int mw_init(char *cmd_buf, uint16_t buf_len)</div><div class="ttdoc">Module initialization. Must be called once before using any other function. It also initializes de UA...</div></div>
<div class="ttc" id="agroup__megawifi_html_ga777c2b3caa535d405278734b0f5aad2e"><div class="ttname"><a href="group__megawifi.html#ga777c2b3caa535d405278734b0f5aad2e">mw_err</a></div><div class="ttdeci">mw_err</div><div class="ttdoc">Error codes for MegaWiFi API functions.</div><div class="ttdef"><b>Definition:</b> <a href="megawifi_8h_source.html#l00047">megawifi.h:47</a></div></div>
<div class="ttc" id="agroup__megawifi_html_ga8227c5ef923c4eee7f978ccf80cff9af"><div class="ttname"><a href="group__megawifi.html#ga8227c5ef923c4eee7f978ccf80cff9af">mw_recv</a></div><div class="ttdeci">static enum lsd_status mw_recv(char *buf, int16_t len, void *ctx, lsd_recv_cb recv_cb)</div><div class="ttdoc">Receive data, asyncrhonous interface.</div><div class="ttdef"><b>Definition:</b> <a href="megawifi_8h_source.html#l00413">megawifi.h:413</a></div></div>
<div class="ttc" id="ampool_8h_html"><div class="ttname"><a href="mpool_8h.html">mpool.h</a></div><div class="ttdoc">Memory Pool.</div></div>
<div class="ttc" id="agroup__loop_html_ga4c3a8dbc5064a8e7d9baffbe604216f1"><div class="ttname"><a href="group__loop.html#ga4c3a8dbc5064a8e7d9baffbe604216f1">loop</a></div><div class="ttdeci">int loop(void)</div><div class="ttdoc">Loop function.</div></div>
<div class="ttc" id="agroup__mpool_html_ga6cd611d9987a2d9dacfdf2b0dce737ad"><div class="ttname"><a href="group__mpool.html#ga6cd611d9987a2d9dacfdf2b0dce737ad">mp_alloc</a></div><div class="ttdeci">void * mp_alloc(uint16_t length) __attribute__((malloc))</div><div class="ttdoc">Allocates data from the pool.</div></div>
<div class="ttc" id="astructloop__timer_html"><div class="ttname"><a href="structloop__timer.html">loop_timer</a></div><div class="ttdoc">Loop timer data structure.</div><div class="ttdef"><b>Definition:</b> <a href="loop_8h_source.html#l00059">loop.h:59</a></div></div>
<div class="ttc" id="agroup__megawifi_html_ggaa395ab95fb1639b3faea74217972dda9a913ca58caf0372816e9499fa366f1ebb"><div class="ttname"><a href="group__megawifi.html#ggaa395ab95fb1639b3faea74217972dda9a913ca58caf0372816e9499fa366f1ebb">MW_IF_STATION</a></div><div class="ttdoc">Station interface.</div><div class="ttdef"><b>Definition:</b> <a href="megawifi_8h_source.html#l00116">megawifi.h:116</a></div></div>
<div class="ttc" id="astructloop__func_html_a53af751bd25418cdb0791f0068959844"><div class="ttname"><a href="structloop__func.html#a53af751bd25418cdb0791f0068959844">loop_func::func_cb</a></div><div class="ttdeci">loop_func_cb func_cb</div><div class="ttdoc">Function callback to run on the loop.</div><div class="ttdef"><b>Definition:</b> <a href="loop_8h_source.html#l00044">loop.h:44</a></div></div>
<div class="ttc" id="aloop_8h_html"><div class="ttname"><a href="loop_8h.html">loop.h</a></div><div class="ttdoc">Loop handling for single threaded Megadrive programs.</div></div>
<div class="ttc" id="agroup__loop_html_ga063359b6f53ca8e491c41807cd4d5760"><div class="ttname"><a href="group__loop.html#ga063359b6f53ca8e491c41807cd4d5760">loop_func_add</a></div><div class="ttdeci">int loop_func_add(struct loop_func *func)</div><div class="ttdoc">Add a function to the loop.</div></div>
<div class="ttc" id="agroup__util_html_gaa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="group__util.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdoc">TRUE value for boolean comparisons.</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00020">util.h:20</a></div></div>
<div class="ttc" id="agroup__megawifi_html_ga635b2e45820d9872badae382a7730153"><div class="ttname"><a href="group__megawifi.html#ga635b2e45820d9872badae382a7730153">mw_gamertag_get</a></div><div class="ttdeci">struct mw_gamertag * mw_gamertag_get(uint8_t slot)</div><div class="ttdoc">Get gamertag information for one slot.</div></div>
<div class="ttc" id="astructmw__gamertag_html_a4d1622737aa1ef49b5cda6c93e3d1036"><div class="ttname"><a href="structmw__gamertag.html#a4d1622737aa1ef49b5cda6c93e3d1036">mw_gamertag::id</a></div><div class="ttdeci">int id</div><div class="ttdoc">Unique gamertag id.</div><div class="ttdef"><b>Definition:</b> <a href="mw-msg_8h_source.html#l00192">mw-msg.h:192</a></div></div>
<div class="ttc" id="agroup__megawifi_html_ga82f774de9f50b730de578cb0e7512d16"><div class="ttname"><a href="group__megawifi.html#ga82f774de9f50b730de578cb0e7512d16">mw_tcp_bind</a></div><div class="ttdeci">enum mw_err mw_tcp_bind(uint8_t ch, uint16_t port)</div><div class="ttdoc">Binds a socket to a port, and listens to connections on the port. If a connection request is received...</div></div>
<div class="ttc" id="autil_8h_html"><div class="ttname"><a href="util_8h.html">util.h</a></div><div class="ttdoc">General purpose utilities.</div></div>
<div class="ttc" id="agroup__megawifi_html_gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f"><div class="ttname"><a href="group__megawifi.html#gga777c2b3caa535d405278734b0f5aad2ea469b336990144c39297268eca750af7f">MW_ERR_NONE</a></div><div class="ttdoc">No error (success)</div><div class="ttdef"><b>Definition:</b> <a href="megawifi_8h_source.html#l00048">megawifi.h:48</a></div></div>
<div class="ttc" id="astructloop__func_html"><div class="ttname"><a href="structloop__func.html">loop_func</a></div><div class="ttdoc">Loop function data structure.</div><div class="ttdef"><b>Definition:</b> <a href="loop_8h_source.html#l00042">loop.h:42</a></div></div>
<div class="ttc" id="agroup__megawifi_html_gab71427cc580c31e355d36eca5e4ab9c4"><div class="ttname"><a href="group__megawifi.html#gab71427cc580c31e355d36eca5e4ab9c4">mw_ap_assoc_wait</a></div><div class="ttdeci">enum mw_err mw_ap_assoc_wait(int tout_frames)</div><div class="ttdoc">Polls the module status until it reports device is associated to AP or timeout occurs.</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
